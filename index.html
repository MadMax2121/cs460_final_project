<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        background: #000;
      }
    </style>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@latest/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
      import { MTLLoader } from "three/addons/loaders/MTLLoader.js";


      let scene, camera, renderer, controls, sphere;
      let car2, clock;
      let currentPath = 'meridian'; // Track which road the car is on
      let transitionPoint = false; // Track if we're at an intersection

      let treeModel;
      const EARTH_RADIUS = 1;
      const placedPositions = []; // Track positions to avoid overlap


      window.onload = function () {
        init();
        animate();
      };

      function init() {
        // Scene
        scene = new THREE.Scene();

        // Camera
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 3);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Lights
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 3, 5);
        scene.add(directionalLight);

        const roadLight = new THREE.DirectionalLight(0xffffff, 0.5);
        roadLight.position.set(-5, -3, 5);
        scene.add(roadLight);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);
        
        // Sphere
        const geometry = new THREE.SphereGeometry(1, 64, 64);
        const textureLoader = new THREE.TextureLoader();
        const grassTexture = textureLoader.load('./grass-texture.jpg');
        const grassMaterial = new THREE.MeshStandardMaterial({
          map: grassTexture,
          side: THREE.DoubleSide,
        });

        sphere = new THREE.Mesh(geometry, grassMaterial);
        scene.add(sphere);

        // Roads
        const roadTexture = new THREE.TextureLoader().load('./road-texture.jpg');
        roadTexture.wrapS = THREE.RepeatWrapping;
        roadTexture.wrapT = THREE.RepeatWrapping;
        roadTexture.repeat.set(5, 1);
        roadTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();

        const roadMaterial = new THREE.MeshStandardMaterial({
          map: roadTexture,
          side: THREE.DoubleSide,
          roughness: 0.8,
          metalness: 0.2,
        });

        // Equatorial Road
        const road1Geometry = new THREE.CylinderGeometry(1.005, 1.005, 0.05, 100, 1, true);
        const road1Mesh = new THREE.Mesh(road1Geometry, roadMaterial);
        road1Mesh.rotation.z = Math.PI / 2;
        sphere.add(road1Mesh);

        // Meridian Road
        const road2Geometry = new THREE.CylinderGeometry(1.005, 1.005, 0.05, 100, 1, true);
        const road2Mesh = new THREE.Mesh(road2Geometry, roadMaterial);
        road2Mesh.rotation.y = Math.PI / 2;
        sphere.add(road2Mesh);

        // Load Car Model
        const loader = new GLTFLoader();
        loader.load('./old_rusty_car.glb', (gltf) => {
          car2 = gltf.scene;
          car2.scale.set(0.0005, 0.0005, 0.0005);
          sphere.add(car2);
        });

        // Load Trees
        loadTree();

        // Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        clock = new THREE.Clock();

        window.addEventListener("resize", onWindowResize, false);
      }

      function loadTree() {
        const mtlLoader = new MTLLoader();
        const objLoader = new OBJLoader();
        const treeMtl = './trees/tree.mtl'; // Replace with actual path
        const treeObj = './trees/tree.obj'; // Replace with actual path

        mtlLoader.load(
          treeMtl,
          (materials) => {
            materials.preload();
            objLoader.setMaterials(materials);
            objLoader.load(
              treeObj,
              (object) => {
                treeModel = object;
                treeModel.traverse((child) => {
                  if (child.isMesh) {
                    child.scale.set(0.002, 0.002, 0.002); // Scale the tree model
                  }
                });
                placeTrees(); // Place trees after the model is loaded
              },
              undefined,
              (error) => console.error(`Failed to load tree model: ${treeObj}`, error)
            );
          },
          undefined,
          (error) => console.error(`Failed to load tree material: ${treeMtl}`, error)
        );
      }

      function placeTrees() {
        for (let i = 0; i < 20; i++) {
          addTree();
        }
      }

      function addTree() {
        if (!treeModel) return;
      
        let position;
        do {
          position = randomLatLonToXYZ();
        } while (isPositionTooClose(position, 0.05));
      
        const tree = treeModel.clone();
        const normal = position.clone().normalize();
        const adjustedPosition = position.addScaledVector(normal, 0.01);
      
        tree.position.copy(adjustedPosition);
        alignObjectToNormal(tree, normal);
        scene.add(tree);
        placedPositions.push(position);
      }

      function isPositionTooClose(position, minDistance) {
        const equatorialPlane = new THREE.Vector3(0, 1, 0); // Y-axis (equator)
        const meridianPlane = new THREE.Vector3(1, 0, 0);  // X-axis (meridian)

        const equatorialDistance = Math.abs(position.dot(equatorialPlane));
        const meridianDistance = Math.abs(position.dot(meridianPlane));

        return (
          placedPositions.some((placedPosition) => {
            return position.distanceTo(placedPosition) < minDistance;
          }) ||
          equatorialDistance < 0.1 || // Ensure tree is away from equator
          meridianDistance < 0.1      // Ensure tree is away from meridian
        );
      }

      function randomLatLonToXYZ() {
        let lat, lon;
        do {
          lat = THREE.MathUtils.randFloat(-90, 90);
          lon = THREE.MathUtils.randFloat(-180, 180);
        } while (
          (Math.abs(lat) < 10) || // Avoid the equatorial road (latitude near 0)
          (Math.abs(lon) < 10)    // Avoid the meridian road (longitude near 0)
        );
        return latLonToXYZ(lat, lon, EARTH_RADIUS);
      }


      function latLonToXYZ(lat, lon, radius = EARTH_RADIUS) {
        const phi = THREE.MathUtils.degToRad(90 - lat);
        const theta = THREE.MathUtils.degToRad(lon);
        const x = radius * Math.sin(phi) * Math.cos(theta);
        const y = radius * Math.cos(phi);
        const z = radius * Math.sin(phi) * Math.sin(theta);
        return new THREE.Vector3(x, y, z);
      }

      function alignObjectToNormal(object, normal) {
        const up = new THREE.Vector3(0, 1, 0);
        const quaternion = new THREE.Quaternion().setFromUnitVectors(up, normal);
        object.quaternion.copy(quaternion);
      }


      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
  requestAnimationFrame(animate);

  if (car2) {
    const time = clock.getElapsedTime();
    const speed = 0.5;
    const radius = 1.005; // Match road radius (slightly above the sphere surface)
    
    //sphere.rotation.y += 0.01;

    // Calculate position on the sphere for rotation around the meridian
    const angle = time * speed; // Rotational angle
    const position = new THREE.Vector3(
      0, // X remains constant for meridian rotation
      radius * Math.cos(angle), // Y changes
      radius * Math.sin(angle)  // Z changes
    );

    // Update the car's position
    car2.position.copy(position);

    // Calculate the sphere's normal at this position
    const normal = position.clone().normalize();

    // Align the car's bottom to the sphere's normal
    const quaternion = new THREE.Quaternion();
    quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), normal);
    car2.quaternion.copy(quaternion);
  }

  controls.update();
  renderer.render(scene, camera);
}

    </script>
  </head>
  <body></body>
</html>