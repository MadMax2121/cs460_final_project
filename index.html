<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        background: #000;
      }
    </style>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@latest/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

      let scene, camera, renderer, controls, sphere;
      let car2, clock;
      let currentPath = 'meridian'; // Track which road the car is on
      let transitionPoint = false; // Track if we're at an intersection

      window.onload = function () {
        init();
        animate();
      };

      function init() {
        // Scene
        scene = new THREE.Scene();

        // Camera
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 3);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Lights
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 3, 5);
        scene.add(directionalLight);

        const roadLight = new THREE.DirectionalLight(0xffffff, 0.5);
        roadLight.position.set(-5, -3, 5);
        scene.add(roadLight);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);
        
        // Sphere
        const geometry = new THREE.SphereGeometry(1, 64, 64);
        const textureLoader = new THREE.TextureLoader();
        const grassTexture = textureLoader.load('./grass-texture.jpg');
        const grassMaterial = new THREE.MeshStandardMaterial({
          map: grassTexture,
          side: THREE.DoubleSide,
        });

        sphere = new THREE.Mesh(geometry, grassMaterial);
        scene.add(sphere);

        // Roads
        const roadTexture = new THREE.TextureLoader().load('./road-texture.jpg');
        roadTexture.wrapS = THREE.RepeatWrapping;
        roadTexture.wrapT = THREE.RepeatWrapping;
        roadTexture.repeat.set(5, 1);
        roadTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();

        const roadMaterial = new THREE.MeshStandardMaterial({
          map: roadTexture,
          side: THREE.DoubleSide,
          roughness: 0.8,
          metalness: 0.2,
        });

        // Equatorial Road
        const road1Geometry = new THREE.CylinderGeometry(1.005, 1.005, 0.05, 100, 1, true);
        const road1Mesh = new THREE.Mesh(road1Geometry, roadMaterial);
        road1Mesh.rotation.z = Math.PI / 2;
        scene.add(road1Mesh);

        // Meridian Road
        const road2Geometry = new THREE.CylinderGeometry(1.005, 1.005, 0.05, 100, 1, true);
        const road2Mesh = new THREE.Mesh(road2Geometry, roadMaterial);
        road2Mesh.rotation.y = Math.PI / 2;
        scene.add(road2Mesh);

        // Load Car Model
        const loader = new GLTFLoader();
        loader.load('./old_rusty_car.glb', (gltf) => {
          car2 = gltf.scene;
          car2.scale.set(0.0005, 0.0005, 0.0005);
          scene.add(car2);
        });

        // Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        clock = new THREE.Clock();

        window.addEventListener("resize", onWindowResize, false);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
  requestAnimationFrame(animate);

  if (car2) {
    const time = clock.getElapsedTime();
    const speed = 0.5;
    const radius = 1.005; // Match road radius (slightly above the sphere surface)

    // Calculate position on the sphere for rotation around the meridian
    const angle = time * speed; // Rotational angle
    const position = new THREE.Vector3(
      0, // X remains constant for meridian rotation
      radius * Math.cos(angle), // Y changes
      radius * Math.sin(angle)  // Z changes
    );

    // Update the car's position
    car2.position.copy(position);

    // Calculate the sphere's normal at this position
    const normal = position.clone().normalize();

    // Align the car's bottom to the sphere's normal
    const quaternion = new THREE.Quaternion();
    quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), normal);
    car2.quaternion.copy(quaternion);
  }

  controls.update();
  renderer.render(scene, camera);
}

    </script>
  </head>
  <body></body>
</html>