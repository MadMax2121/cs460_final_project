<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rotating Earth with Roads, Buildings, and Trees</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #87ceeb; /* Sky-like background */
    }
  </style>

  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@latest/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
    import { MTLLoader } from "three/addons/loaders/MTLLoader.js";

    let scene, camera, renderer, controls, earth, clock;
    let car1, car2;
    let buildingVariants = [];
    let treeModel = null; // Store the loaded tree model
    const EARTH_RADIUS = 1;
    const placedPositions = []; // Track placed objects to avoid overlaps

    window.onload = function () {
      init();
      animate();
    };

    function init() {
      // Scene
      scene = new THREE.Scene();

      // Camera
      const fov = 60;
      const aspect = window.innerWidth / window.innerHeight;
      const near = 0.1;
      const far = 1000;
      camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      camera.position.set(0, 2.5, 4);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      // Lights
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
      directionalLight.position.set(5, 10, 5);
      scene.add(directionalLight);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);

      // Grass Textured Earth
      const earthGeometry = new THREE.SphereGeometry(EARTH_RADIUS, 64, 64);
      const grassTexture = new THREE.TextureLoader().load('./grass-texture.jpg');
      const earthMaterial = new THREE.MeshStandardMaterial({
        map: grassTexture,
        side: THREE.DoubleSide,
      });
      earth = new THREE.Mesh(earthGeometry, earthMaterial);
      scene.add(earth);

      // Load Models
      loadBuildings();
      loadTree();

      // Roads
      addRoads();

      // Cars
      addCars();

      // Orbit Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Clock for animations
      clock = new THREE.Clock();

      // Resize handling
      window.addEventListener("resize", onWindowResize, false);
    }

    function loadTree() {
      const mtlLoader = new MTLLoader();
      const objLoader = new OBJLoader();
      const treeMtl = './trees/tree.mtl'; // Single tree's .mtl file
      const treeObj = './trees/tree.obj'; // Single tree's .obj file

      mtlLoader.load(
        treeMtl,
        (materials) => {
          materials.preload();
          objLoader.setMaterials(materials);
          objLoader.load(
            treeObj,
            (object) => {
              treeModel = object;
              treeModel.traverse((child) => {
                if (child.isMesh) {
                  child.scale.set(0.0015, 0.0015, 0.0015); // Normalize size
                }
              });
              createBuildingsAndTrees(); // Add trees and buildings when loaded
            },
            undefined,
            (error) => console.error(`Failed to load tree: ${treeObj}`, error)
          );
        },
        undefined,
        (error) => console.error(`Failed to load material: ${treeMtl}`, error)
      );
    }

    function loadBuildings() {
      const mtlLoader = new MTLLoader();
      const objLoader = new OBJLoader();

      const buildingFiles = [
        { mtl: './buildings/skyscraper_02.mtl', obj: './buildings/skyscraper_02.obj' },
        
      ];

      let loadedCount = 0;

      buildingFiles.forEach((file) => {
        mtlLoader.load(
          file.mtl,
          (materials) => {
            materials.preload();
            objLoader.setMaterials(materials);
            objLoader.load(
              file.obj,
              (object) => {
                object.traverse((child) => {
                  if (child.isMesh) {
                    child.scale.set(0.002, 0.002, 0.002); // Scale buildings
                    buildingVariants.push(child);
                  }
                });
                loadedCount++;
                if (loadedCount === buildingFiles.length && treeModel) {
                  createBuildingsAndTrees(); // Create objects once all models are loaded
                }
              },
              undefined,
              (error) => console.error(`Failed to load object: ${file.obj}`, error)
            );
          },
          undefined,
          (error) => console.error(`Failed to load material: ${file.mtl}`, error)
        );
      });
    }

    function addRoads() {
      const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

      // Equatorial Road
      const equatorialGeometry = new THREE.CylinderGeometry(1.005, 1.005, 0.05, 100, 1, true);
      const equatorialRoad = new THREE.Mesh(equatorialGeometry, roadMaterial);
      equatorialRoad.rotation.y = Math.PI / 2;
      earth.add(equatorialRoad);

      // Meridional Road
      const meridionalGeometry = new THREE.CylinderGeometry(1.005, 1.005, 0.05, 100, 1, true);
      const meridionalRoad = new THREE.Mesh(meridionalGeometry, roadMaterial);
      meridionalRoad.rotation.x = Math.PI / 2;
      earth.add(meridionalRoad);
    }

    function createBuildingsAndTrees() {
      const quadrants = [
        { latRange: [0, 60], lonRange: [0, 150] },
        { latRange: [0, 60], lonRange: [-150, 0] },
        { latRange: [-60, 0], lonRange: [-150, 0] },
        { latRange: [-60, 0], lonRange: [0, 150] },
      ];

      quadrants.forEach((quadrant) => {
        for (let i = 0; i < 5; i++) addBuilding(quadrant.latRange, quadrant.lonRange);
        for (let i = 0; i < 8; i++) addTree(quadrant.latRange, quadrant.lonRange);
      });
    }

    function addBuilding(latRange, lonRange) {
      if (buildingVariants.length === 0) return;

      let position;
      do {
        position = randomLatLonToXYZ(latRange, lonRange);
      } while (isPositionTooClose(position, 0.03));

      const building = buildingVariants[Math.floor(Math.random() * buildingVariants.length)].clone();
      const normal = position.clone().normalize();
      const adjustedPosition = position.addScaledVector(normal, 0.01);

      building.position.copy(adjustedPosition);
      alignObjectToNormal(building, normal);
      earth.add(building);
      placedPositions.push(position);
    }

    function addTree(latRange, lonRange) {
      if (!treeModel) return;

      let position;
      do {
        position = randomLatLonToXYZ(latRange, lonRange);
      } while (isPositionTooClose(position, 0.03));

      const tree = treeModel.clone();
      const normal = position.clone().normalize();
      const adjustedPosition = position.addScaledVector(normal, 0.01);

      tree.position.copy(adjustedPosition);
      alignObjectToNormal(tree, normal);
      earth.add(tree);
      placedPositions.push(position);
    }

    function isPositionTooClose(position, minDistance) {
      return placedPositions.some((placedPosition) => {
        return position.distanceTo(placedPosition) < minDistance;
      });
    }

    function addCars() {
      const carGeometry = new THREE.BoxGeometry(0.1, 0.05, 0.05);
      const carMaterial1 = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      const carMaterial2 = new THREE.MeshBasicMaterial({ color: 0x0000ff });

      car1 = new THREE.Mesh(carGeometry, carMaterial1);
      car2 = new THREE.Mesh(carGeometry, carMaterial2);

      earth.add(car1);
      earth.add(car2);
    }

    function randomLatLonToXYZ(latRange, lonRange) {
      let lat, lon;
      do {
        lat = THREE.MathUtils.randFloat(latRange[0], latRange[1]);
        lon = THREE.MathUtils.randFloat(lonRange[0], lonRange[1]);
      } while (
        (lat > -20 && lat < 20) || // Avoid equatorial road
        (lon > -20 && lon < 20)   // Avoid meridional road
      );

      return latLonToXYZ(lat, lon, EARTH_RADIUS);
    }

    function latLonToXYZ(lat, lon, radius = EARTH_RADIUS) {
      const phi = THREE.MathUtils.degToRad(90 - lat);
      const theta = THREE.MathUtils.degToRad(lon);
      const x = radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.cos(phi);
      const z = radius * Math.sin(phi) * Math.sin(theta);
      return new THREE.Vector3(x, y, z);
    }

    function alignObjectToNormal(object, normal) {
      const up = new THREE.Vector3(0, 1, 0);
      const q = new THREE.Quaternion().setFromUnitVectors(up, normal);
      object.quaternion.copy(q);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      const time = clock.getElapsedTime();

      // Animate cars
      car1.position.set(Math.cos(time) * 1.05, 0, Math.sin(time) * 1.05);
      car2.position.set(Math.sin(time) * 1.02, Math.cos(time) * 1.02, 0);

      // Rotate Earth
      earth.rotation.y += 0.001;

      // Render
      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</head>
<body></body>
</html>
